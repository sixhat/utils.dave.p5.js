// utils.dave.p5.js v.37
class Dave {
  // Short version of functions bellow.
  constructor() {
    this.grid = new Grid();
    this.g = this.grid;
    this.f = this.fillHsluv;
    this.s = this.strokeHsluv;
  }
  
  // sets fill according to hsluv parameters
  fillHsluv(h, s, l) {
    let rgb = hsluv.hsluvToRgb([h, s, l]);
    fill(rgb[0] * 255, rgb[1] * 255, rgb[2] * 255);
  }
  // sets stroke according to hsluv parameters
  strokeHsluv(h, s, l) {
    let rgb = hsluv.hsluvToRgb([h, s, l]);
    stroke(rgb[0] * 255, rgb[1] * 255, rgb[2] * 255);
  }
  // Create a fast get function to use instead of in P5.
  pget(x, y, img) {
    img.loadPixels();
    let d = pixelDensity();

    for (var i = 0; i < d; i++) {
      for (var j = 0; j < d; j++) {
        // loop over
        let idx = 4 * ((y * d + j) * img.width * d + (x * d + i));
        pixels[idx] = r;
        pixels[idx + 1] = g;
        pixels[idx + 2] = b;
        pixels[idx + 3] = a;
      }
    }
    // Things to take into consideration: x,y must be in image.
    // pixelDensity has to be taken into consideration.
    // loadPixels should be called only during the first time for this particular image.
  }
}
//  A simple Grid System to place over drawings
class Grid {
  constructor() {
    this.horizontal = [];
    this.vertical = [];
    this.rectangles = [];
    this.color = color("#FF00FFAA");
  }
  show() {
    push();
    stroke(this.color);
    noFill();
    rectMode(CORNERS);
    
    this.horizontal.forEach(y => line(0, y, width, y));
    this.vertical.forEach(x => line(x, 0, x, height));
    this.rectangles.forEach( r => rect(r[0], r[1], r[2], r[3]));
    pop();
  }
  clear() {
    this.clearHorizontal();
    this.clearVertical();
    this.clearRectangles();
    this.color = color("#FF00FFAA");
  }
  clearHorizontal() {
    this.horizontal = [];
  }
  clearVertical() {
    this.vertical = [];
  }
  clearRectangles() {
    this.rectangles = [];
  }
}
// Generated by CoffeeScript 2.3.2
var LSystem;

LSystem = class LSystem {
  constructor(alphabet, axiom, rules) {
    this.alphabet = alphabet;
    this.axiom = axiom;
    this.rules = rules;
    this.startString = this.axiom;
    this.endString = '';
    this.nIters = 0;
  }

  processString(oldStr) {
    var c, i, len, newStr;
    newStr = '';
    for (i = 0, len = oldStr.length; i < len; i++) {
      c = oldStr[i];
      newStr += (this.rules[c] ? this.rules[c] : c);
    }
    return newStr;
  }

  iterate(nIters) {
    var i, n, ref;
    if (nIters < 1) {
      return this.endStrig;
    }
    for (n = i = 1, ref = nIters; (1 <= ref ? i <= ref : i >= ref); n = 1 <= ref ? ++i : --i) {
      this.endString = this.processString(this.startString);
      this.startString = this.endString;
    }
    this.nIters += nIters;
    return this.endString;
  }

  addRule(key, action) {
    return this.rules[key] = action;
  }

  removeRule(key) {
    return delete this.rules[key];
  }

};
// The Turtle class implements the basic methods of Turtle graphics from the logo languages.
class Turtle {
  constructor(x, y, heading) {
    this.x = x | 0;
    this.y = y | 0;
    this.penDown = true;
    this.penColor = 0;
    this.penWeight = 1;
    this.heading = heading | -HALF_PI;
    this.stack = [];
  }
  // This function draws an L-System based on default values.
  // The turtle knows how to draw certain types of LSystems
  // F means forward with pen down
  // f means fordward with pen up
  // X or any other letter pass.
  // [ push
  // ] pop
  // + turn right
  // - turn left
  drawLSystem(ls, step, angle) {
    this.drawString(ls.endString, step, angle);
  }

  // Draw a string (used by drawLSystem, but can be generic)
  drawString(string, step, angle) {
    for (let letter of string) {
      switch (letter) {
        case "F":
          this.pd();
          this.fw(step);
          break;
        case "f":
          this.pu();
          this.fw(step);
          break;
        case "[":
          this.push();
          break;
        case "]":
          this.pop();
          break;
        case "+":
          this.rt(angle);
          break;
        case "-":
          this.lt(angle);
          break;
        default:
      }
    }
  }

  // Pushes the current state of turtle to stack.
  push() {
    this.stack.push({
      x: this.x,
      y: this.y,
      penDown: this.penDown,
      penColor: this.penColor,
      penWeight: this.penWeight,
      heading: this.heading
    });
  }
  // Reverts to previous saved state of the turtle removing it from the stack.
  pop() {
    const el = this.stack.pop();
    this.x = el.x;
    this.y = el.y;
    this.penDown = el.penDown;
    this.penColor = el.penColor;
    this.penWeight = el.penWeight;
    this.heading = el.heading;
  }
  // Alias to color
  cl(c) {
    this.color(c);
  }
  color(c) {
    this.penColor = c;
  }
  // Alias to up
  pu() {
    this.up();
  }
  up() {
    this.penDown = false;
  }
  // Alias to down
  pd() {
    this.down();
  }
  down() {
    this.penDown = true;
  }
  // Alias to right
  rt(r) {
    this.right(r);
  }
  right(rot) {
    this.heading += radians(rot);
  }
  // Alias to left
  lt(l) {
    this.left(l);
  }
  left(rot) {
    this.heading -= radians(rot);
  }
  // Set turtle position in coordinate system
  pos(x, y) {
    this.x = x;
    this.y = y;
  }
  // Alias to forward
  fd(s) {
    this.forward(s);
  }
  // Alias to forward
  fw(s) {
    this.forward(s);
  }
  forward(steps) {
    const tx = this.x + steps * cos(this.heading);
    const ty = this.y + steps * sin(this.heading);
    if (this.penDown) {
      push();
      stroke(this.penColor);
      strokeWeight(this.penWeight);
      line(this.x, this.y, tx, ty);
      pop();
    }
    this.x = tx;
    this.y = ty;
  }
  // Alias to backward
  bk(s) {
    this.backward(s);
  }
  // Alias to backward
  back(s) {
    this.backward(s);
  }
  // Moves the turtle backwards without painting.
  backward(steps) {
    const ps = this.penDown;
    this.penDown = false;
    this.forward(-steps);
    this.penDown = ps;
  }
  // Alias to style
  st(s) {
    this.style(s);
  }
  style(weight) {
    this.penWeight = weight;
  }
  // Set heading of turtle East=0, CW
  hd(h) {
    this.heading = radians(h);
  }
}
