// utils.dave.p5.js v.74
class Dave {
  // Short version of functions bellow.
  constructor() {
    this.grid = new Grid();
    this.g = this.grid;
    this.f = this.fillHsluv;
    this.s = this.strokeHsluv;
  }
  
  // sets fill according to hsluv parameters
  fillHsluv(h, s, l) {
    let rgb = hsluv.hsluvToRgb([h, s, l]);
    fill(rgb[0] * 255, rgb[1] * 255, rgb[2] * 255);
  }
  // sets stroke according to hsluv parameters
  strokeHsluv(h, s, l) {
    let rgb = hsluv.hsluvToRgb([h, s, l]);
    stroke(rgb[0] * 255, rgb[1] * 255, rgb[2] * 255);
  }
  // Create a fast get function to use instead of in P5.
  pget(x, y, img) {
    img.loadPixels();
    let d = pixelDensity();

    for (var i = 0; i < d; i++) {
      for (var j = 0; j < d; j++) {
        // loop over
        let idx = 4 * ((y * d + j) * img.width * d + (x * d + i));
        pixels[idx] = r;
        pixels[idx + 1] = g;
        pixels[idx + 2] = b;
        pixels[idx + 3] = a;
      }
    }
    // Things to take into consideration: x,y must be in image.
    // pixelDensity has to be taken into consideration.
    // loadPixels should be called only during the first time for this particular image.
  }
}

// Simples construtor de paletas de cores.
const paleta = {
  cor: [],
  tom: function(n, sat = 100, luz = 100) {
    colorMode(HSB, 360, 100, 100, 100);
    const step = 360 / (n - 1);
    while (n-- > 0) {
      this.cor[this.cor.length] = color(360 - n * step, sat, luz);
    }
  },
  luz: function(n = 10, tom = random(360), sat = 100) {
    colorMode(HSB, 360, 100, 100, 100);
    const step = 100 / (n - 1);
    while (n-- > 0) {
      this.cor[this.cor.length] = color(tom, sat, 100 - n * step);
    }
  },
  sat: function(n = 10, tom = random(360), luz = 100) {
    colorMode(HSB, 360, 100, 100, 100);
    const step = 100 / (n - 1);
    while (n-- > 0) {
      this.cor[this.cor.length] = color(tom, 100 - n * step, luz);
    }
  }
}
class Grid {
  constructor(linhas = 1, colunas = 1, margem = 0, gutter = 0, largura = width, altura = height) {
    this.linhas = linhas;
    this.colunas = colunas;
    this.margem = margem;
    this.gutter = gutter;
    this.largura = largura;
    this.altura = altura;
}
  compute() {
    this.areaw = (this.largura - 2 * this.margem - (this.colunas - 1) * this.gutter) / this.colunas;
    this.areah = (this.altura - 2 * this.margem - (this.linhas - 1) * this.gutter) / this.linhas;
    this.areas = [];
    this.areas.length = this.linhas;
    for (let linha = 0; linha < this.linhas; linha++) {
      this.areas[linha] = [];
      for (let coluna = 0; coluna < this.colunas; coluna++) {
        const box = {
          x: this.margem + (this.areaw + this.gutter) * coluna,
          y: this.margem + (this.areah + this.gutter) * linha,
          w: this.areaw,
          h: this.areah
        }
        this.areas[linha][coluna] = box;
      }
    }
  }
  render(encher = false) {
    push();
    resetMatrix();
    stroke('pink');
    if (encher) {
      fill(encher);
    } else {
      noFill();
    }
    textSize(10);
    for (let linha = 0; linha < this.linhas; linha++) {
      for (let coluna = 0; coluna < this.colunas; coluna++) {
        const box = this.areas[linha][coluna];
        rect(box.x, box.y, box.w, box.h);
        text(linha * this.colunas + coluna, box.x + 2, box.y + 10);
      }
    }
    pop();
  }
  area(inicio = 0, fim = 0) {
    if (fim < inicio) {
      const aux = fim;
      fim = inicio;
      inicio = aux;
    }
    if (fim >= this.linhas * this.colunas) {
      console.log('ERRO: Ã¡rea FIM fora da grelha');
      return;
    }

    const ilin = Math.floor(inicio / this.colunas);
    const icol = inicio % this.colunas;
    const flin = Math.floor(fim / this.colunas);
    const fcol = fim % this.colunas;

    return {
      x: this.areas[ilin][icol].x,
      y: this.areas[ilin][icol].y,
      w: this.areas[flin][fcol].x + this.areas[flin][fcol].w - this.areas[ilin][icol].x,
      h: this.areas[flin][fcol].y + this.areas[flin][fcol].h - this.areas[ilin][icol].y
    };
  }
}

//  Simple Manual Guides to place over drawings
class Guides {
  constructor() {
    this.horizontal = [];
    this.vertical = [];
    this.rectangles = [];
    this.color = color("#FF00FFAA");
  }
  show() {
    push();
    stroke(this.color);
    noFill();
    rectMode(CORNERS);

    this.horizontal.forEach(y => line(0, y, width, y));
    this.vertical.forEach(x => line(x, 0, x, height));
    this.rectangles.forEach(r => rect(r[0], r[1], r[2], r[3]));
    pop();
  }
  clear() {
    this.clearHorizontal();
    this.clearVertical();
    this.clearRectangles();
    this.color = color("#FF00FFAA");
  }
  clearHorizontal() {
    this.horizontal = [];
  }
  clearVertical() {
    this.vertical = [];
  }
  clearRectangles() {
    this.rectangles = [];
  }
}
// Generated by CoffeeScript 2.5.0
var LSystem;

LSystem = class LSystem {
  constructor(alphabet, axiom, rules) {
    this.alphabet = alphabet;
    this.axiom = axiom;
    this.rules = rules;
    this.startString = this.axiom;
    this.endString = '';
    this.nIters = 0;
  }

  processString(oldStr) {
    var c, i, len, newStr;
    newStr = '';
    for (i = 0, len = oldStr.length; i < len; i++) {
      c = oldStr[i];
      newStr += (this.rules[c] ? this.rules[c] : c);
    }
    return newStr;
  }

  iterate(nIters) {
    var i, n, ref;
    if (nIters < 1) {
      return this.endStrig;
    }
    for (n = i = 1, ref = nIters; (1 <= ref ? i <= ref : i >= ref); n = 1 <= ref ? ++i : --i) {
      this.endString = this.processString(this.startString);
      this.startString = this.endString;
    }
    this.nIters += nIters;
    return this.endString;
  }

  addRule(key, action) {
    return this.rules[key] = action;
  }

  removeRule(key) {
    return delete this.rules[key];
  }

};
// The Turtle class implements the basic methods of Turtle graphics from the logo languages.
class Turtle {
  constructor(x, y, heading) {
    this.x = x | 0;
    this.y = y | 0;
    this.penDown = true;
    this.penColor = 0;
    this.penWeight = 1;
    this.heading = heading || -HALF_PI;
    this.stack = [];
    this.cl = this.color;
    this.pu = this.up;
    this.pd = this.down;
    this.rt = this.right;
    this.lt = this.left;
    this.fd = this.forward;
    this.fw = this.forward;
    this.fwd = this.forward;
    this.bk = this.backward;
    this.back = this.backward;
    this.st = this.style;
  }
  // This function draws an L-System based on default values.
  // The turtle knows how to draw certain types of LSystems
  // F means forward with pen down
  // f means fordward with pen up
  // X or any other letter pass.
  // [ push
  // ] pop
  // + turn right
  // - turn left
  drawLSystem(ls, step, angle) {
    this.drawString(ls.endString, step, angle);
  }

  // Draw a string (used by drawLSystem, but can be generic)
  drawString(string, step, angle) {
    const draw = {
      "f": e => { e.pu; e.forward(step) },
      "F": e => { e.pd; e.forward(step) },
      "[": e => e.push(),
      "]": e => e.pop(),
      "+": e => e.right(angle),
      "-": e => e.left(angle)
    };
    const commands = Object.keys(draw);
    [...string].forEach(letter => {
      if (commands.includes(letter)) draw[letter](this);
    });
  }

  // Pushes the current state of turtle to stack.
  push() {
    this.stack.push({
      x: this.x,
      y: this.y,
      penDown: this.penDown,
      penColor: this.penColor,
      penWeight: this.penWeight,
      heading: this.heading
    });
  }
  // Reverts to previous saved state of the turtle removing it from the stack.
  pop() {
    const el = this.stack.pop();
    this.x = el.x;
    this.y = el.y;
    this.penDown = el.penDown;
    this.penColor = el.penColor;
    this.penWeight = el.penWeight;
    this.heading = el.heading;
  }

  show() {
    this.push();
    stroke('pink');
    this.down();
    this.rt(10);
    this.fd(-10);
    this.fd(10);
    this.lt(20);
    this.fd(-10);
    this.pop();
  }

  color(c) {
    this.penColor = c;
  }
  up() {
    this.penDown = false;
  }
  down() {
    this.penDown = true;
  }
  right(rot) {
    this.heading += radians(rot);
  }
  left(rot) {
    this.heading -= radians(rot);
  }
  // Set turtle position in coordinate system
  pos(x, y) {
    this.x = x;
    this.y = y;
  }
  forward(steps) {
    const tx = this.x + steps * cos(this.heading);
    const ty = this.y + steps * sin(this.heading);
    if (this.penDown) {
      push();
      stroke(this.penColor);
      strokeWeight(this.penWeight);
      line(this.x, this.y, tx, ty);
      pop();
    }
    this.x = tx;
    this.y = ty;
  }
  // Moves the turtle backwards without painting.
  backward(steps) {
    const ps = this.penDown;
    this.penDown = false;
    this.forward(-steps);
    this.penDown = ps;
  }
  style(weight) {
    this.penWeight = weight;
  }
  // Set heading of turtle East=0, CW
  hd(h) {
    this.heading = radians(h);
  }
}
